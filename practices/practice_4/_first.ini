Чтобы написать приложение на Angular в 2025 году, тебе нужно знать **современный стиль (Modern Angular)**: Standalone Components, Signals (Сигналы) и новый синтаксис шаблонов.

Вот **база**, с которой можно собрать 90% функционала любого приложения.

---

### 1. Компонент (Component) — Кирпичик приложения
Всё приложение состоит из компонентов. Это класс (логика) + шаблон (HTML) + стили (CSS).

**Файл: `user-card.component.ts`**
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-user-card', // Как использовать в HTML: <app-user-card></app-user-card>
  standalone: true,          // Современный стандарт (без NgModule)
  imports: [],               // Сюда импортируем другие компоненты или инструменты
  template: `
    <div class="card">
      <h2>Привет, Angular!</h2>
    </div>
  `,
  styleUrl: './user-card.component.css'
})
export class UserCardComponent {
  // Тут пишем логику (переменные, функции)
}
```

---

### 2. Данные и Состояние (Signals)
Забудь про простые переменные. Используй **Signals** (Сигналы), чтобы Angular знал, когда обновлять экран.

```typescript
import { Component, signal } from '@angular/core';

@Component({ ... })
export class CounterComponent {
  // 1. Создаем сигнал (начальное значение 0)
  count = signal(0); 
  
  // Обычная переменная (не меняется реактивно)
  title = 'Счетчик';

  increment() {
    // 2. Обновляем сигнал
    this.count.update(value => value + 1);
  }

  reset() {
    // 3. Устанавливаем конкретное значение
    this.count.set(0);
  }
}
```

**В HTML:**
```html
<h1>{{ title }}</h1>
<!-- Чтобы прочитать сигнал, вызываем его как функцию () -->
<p>Текущий счет: {{ count() }}</p> 
```

---

### 3. Обработка событий (Events)
Как реагировать на клики, ввод текста и т.д.
Синтаксис: `(событие)="метод()"`

```html
<!-- Клик -->
<button (click)="saveData()">Сохранить</button>

<!-- Ввод текста -->
<input (input)="onType($event)">

<!-- Наведение мыши -->
<div (mouseenter)="showTooltip()">Наведи на меня</div>
```

---

### 4. Управление потоком (Control Flow)
Новый, удобный синтаксис (вместо старых `*ngIf`, `*ngFor`).

**Условие (@if):**
```html
@if (isLoading()) {
  <p>Загрузка...</p>
} @else {
  <p>Данные загружены!</p>
}
```

**Цикл (@for):**
```html
<ul>
  <!-- track обязателен для производительности (обычно id) -->
  @for (user of users(); track user.id) {
    <li>{{ user.name }}</li>
  } @empty {
    <li>Список пуст</li>
  }
</ul>
```

---

### 5. Работа с формами (Двустороннее связывание)
Чтобы связать `input` и переменную: меняешь в поле — меняется в коде, и наоборот.
*Нужен импорт `FormsModule`.*

```typescript
import { FormsModule } from '@angular/forms';

@Component({
  standalone: true,
  imports: [FormsModule], // Важно добавить сюда
  template: `
    <input [(ngModel)]="userName">
    <p>Вы ввели: {{ userName }}</p>
  `
})
export class FormComponent {
  userName = '';
}
```

---

### 6. Передача данных между компонентами
Как передать данные от Родителя к Ребенку и обратно.

**Родитель (HTML):**
```html
<!-- Передаем name (Input) и слушаем delete (Output) -->
<app-user-item 
  [name]="'Алекс'" 
  (delete)="onDelete()">
</app-user-item>
```

**Ребенок (Child Component TS):**
```typescript
import { Component, input, output } from '@angular/core';

@Component({ ... })
export class UserItemComponent {
  // INPUT: Принимаем данные (read-only сигнал)
  name = input.required<string>(); 

  // OUTPUT: Отправляем событие наверх
  delete = output<void>();

  onRemoveClick() {
    this.delete.emit(); // Сигнализируем родителю
  }
}
```

---

### 7. Сервисы (Services) — Где хранить бизнес-логику
Не пиши сложную логику и запросы к серверу внутри Компонентов. Выноси в Сервисы.

**Файл: `data.service.ts`**
```typescript
import { Injectable, signal } from '@angular/core';

@Injectable({ providedIn: 'root' }) // Доступен везде
export class DataService {
  private users = signal(['Alice', 'Bob']);

  getUsers() {
    return this.users;
  }
  
  addUser(name: string) {
    this.users.update(u => [...u, name]);
  }
}
```

**Использование в Компоненте:**
```typescript
import { inject } from '@angular/core';
import { DataService } from './data.service';

export class UserListComponent {
  // Современный способ внедрения зависимости
  private dataService = inject(DataService);
  
  users = this.dataService.getUsers();
}
```

---

### 8. Роутинг (Навигация)
Как переключать страницы.

**1. Настройка (`app.routes.ts`):**
```typescript
export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'user/:id', component: UserDetailComponent }, // С параметром
];
```

**2. Куда вставлять страницы (`app.component.html`):**
```html
<nav>
  <!-- routerLink вместо href, чтобы не перезагружать страницу -->
  <a routerLink="/">Главная</a>
  <a routerLink="/about">О нас</a>
</nav>

<!-- Здесь будут меняться компоненты -->
<router-outlet></router-outlet>
```

---

### 9. Запросы к серверу (HTTP)
*В `app.config.ts` нужно добавить `provideHttpClient()`.*

```typescript
import { HttpClient } from '@angular/common/http';
import { inject } from '@angular/core';

export class ApiService {
  http = inject(HttpClient);

  getData() {
    // Возвращает Observable (поток)
    return this.http.get('https://api.example.com/items');
  }
}
```
*В компоненте подписываемся на данные:*
```typescript
this.apiService.getData().subscribe(data => {
  console.log(data);
});
```

---

### Краткий алгоритм действий:
1.  Создай проект: `ng new my-app`
2.  Создай компонент: `ng g c components/header`
3.  Создай сервис для данных: `ng g s services/todo`
4.  В сервисе создай `signal` для хранения состояния (список дел, например).
5.  В компоненте сделай `inject` сервиса и выведи данные через `@for` в HTML.
6.  Добавь кнопки и `(click)` для вызова методов сервиса.